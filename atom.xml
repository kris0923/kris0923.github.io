<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>生活不只有眼前的苟且，还有诗和远方的田野</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kris0923.github.io/"/>
  <updated>2019-07-17T15:13:53.883Z</updated>
  <id>https://kris0923.github.io/</id>
  
  <author>
    <name>Magicio</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式之命令模式</title>
    <link href="https://kris0923.github.io/2019/07/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>https://kris0923.github.io/2019/07/17/设计模式之命令模式/</id>
    <published>2019-07-17T15:11:48.000Z</published>
    <updated>2019-07-17T15:13:53.883Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>将“请求”封装成命令对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操做。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>当需要将发出请求的对象和执行请求的对象解耦的时候，使用命令模式。比如我们有一个遥控器，需要控制客厅灯的点亮和关闭，电视的打开和关闭，风扇的关闭等，这是需要遥控器判断当前的对象类型，并执行不同的操作，此时就可以使用命令模式将遥控器和电灯，电视，风扇解耦</p><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>假设有一下三个类，分别表示电灯，电风扇和电视：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Class Light</span><br><span class="line"> */</span><br><span class="line">class Light</span><br><span class="line">&#123;</span><br><span class="line">    public function on()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public function off()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Class ElectricFan</span><br><span class="line"> */</span><br><span class="line">class ElectricFan</span><br><span class="line">&#123;</span><br><span class="line">    public function on()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public function off()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public function speedHigh()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public function speedLow()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * Class Television</span><br><span class="line"> */</span><br><span class="line">class Television</span><br><span class="line">&#123;</span><br><span class="line">    public function on()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public function off()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public function voiceHigh()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public function voiceLow()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>按照一般的写法，当我们需要在实现遥控器类的时候可能会这样写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Class RemoteControl</span><br><span class="line"> */</span><br><span class="line">class RemoteControl</span><br><span class="line">&#123;</span><br><span class="line">    private $light;</span><br><span class="line">    private $electricFan;</span><br><span class="line">    private $television;</span><br><span class="line"></span><br><span class="line">    public function __construct(Light $light, ElectricFan $electricFan, Television $television)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;light = $light;</span><br><span class="line">        $this-&gt;electricFan = $electricFan;</span><br><span class="line">        $this-&gt;television = $television;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function lightOn()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;light-&gt;on();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function lightOff()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;light-&gt;Off();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // other function </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出来，当需要让遥控器遥控另一个电器，则还需要修改遥控器类的实现，是不是很麻烦。</p><h2 id="使用命令模式实现遥控器类"><a href="#使用命令模式实现遥控器类" class="headerlink" title="使用命令模式实现遥控器类"></a>使用命令模式实现遥控器类</h2><p>既然上面的写法比较麻烦，每次都需要修改控制器的代码，那么换个思路把每一个命令作为一个对象来实现。仍然使用上面的三个被遥控的电器类，但这次我们把没一个命令作为一个对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">interface Command</span><br><span class="line">&#123;</span><br><span class="line">    public function execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 开灯</span><br><span class="line"> * Class LightOnCommand</span><br><span class="line"> * @package App</span><br><span class="line"> */</span><br><span class="line">class LightOnCommand implements Command</span><br><span class="line">&#123;</span><br><span class="line">    private $light;</span><br><span class="line">    public function __construct(Light $light)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;light = $light;</span><br><span class="line">    &#125;</span><br><span class="line">    public function execute()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;light-&gt;on();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 关灯</span><br><span class="line"> * Class LightOffCommand</span><br><span class="line"> * @package App</span><br><span class="line"> */</span><br><span class="line">class LightOffCommand implements Command</span><br><span class="line">&#123;</span><br><span class="line">    private $light;</span><br><span class="line">    public function __construct(Light $light)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;light = $light;</span><br><span class="line">    &#125;</span><br><span class="line">    public function execute()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;light-&gt;off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 开风扇</span><br><span class="line"> * Class ElectricFanOnCommand</span><br><span class="line"> * @package App</span><br><span class="line"> */</span><br><span class="line">class ElectricFanOnCommand implements Command</span><br><span class="line">&#123;</span><br><span class="line">    private $electricFan;</span><br><span class="line">    public function __construct(ElectricFan $electricFan)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;electricFan = $electricFan;</span><br><span class="line">    &#125;</span><br><span class="line">    public function execute()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;electricFan-&gt;on();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 关风扇</span><br><span class="line"> * Class ElectricFanOffCommand</span><br><span class="line"> * @package App</span><br><span class="line"> */</span><br><span class="line">class ElectricFanOffCommand implements Command</span><br><span class="line">&#123;</span><br><span class="line">    private $electricFan;</span><br><span class="line">    public function __construct(ElectricFan $electricFan)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;electricFan = $electricFan;</span><br><span class="line">    &#125;</span><br><span class="line">    public function execute()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;electricFan-&gt;off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 开电视</span><br><span class="line"> * Class ElectricFanOnCommand</span><br><span class="line"> * @package App</span><br><span class="line"> */</span><br><span class="line">class TelevisionOnCommand implements Command</span><br><span class="line">&#123;</span><br><span class="line">    private $television;</span><br><span class="line">    public function __construct(Television $television)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;electricFan = $television;</span><br><span class="line">    &#125;</span><br><span class="line">    public function execute()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;television-&gt;on();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 关电视</span><br><span class="line"> * Class ElectricFanOffCommand</span><br><span class="line"> * @package App</span><br><span class="line"> */</span><br><span class="line">class TelevisionOffCommand implements Command</span><br><span class="line">&#123;</span><br><span class="line">    private $television;</span><br><span class="line">    public function __construct(Television $television)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;electricFan = $television;</span><br><span class="line">    &#125;</span><br><span class="line">    public function execute()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;television-&gt;off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 其他的命令类似</span><br></pre></td></tr></table></figure></p><p>这样我们就可以这样实现遥控器类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class RemoteControl</span><br><span class="line">&#123;</span><br><span class="line">    private $onCommand = [];</span><br><span class="line">    private $offCommand =[];</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * RemoteControl constructor.</span><br><span class="line">     * @param array $onCommand Command 数组</span><br><span class="line">     * @param array $offCommand Command 数组</span><br><span class="line">     */</span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function setCommand(int $position, Command $onCommand, Command $offCommand)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;onCommand[$position] = $onCommand;</span><br><span class="line">        $this-&gt;offCommand[$position] = $offCommand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 打开</span><br><span class="line">     */</span><br><span class="line">    public function pressOn()</span><br><span class="line">    &#123;</span><br><span class="line">        foreach ($this-&gt;onCommand as $command) &#123;</span><br><span class="line">            $command-&gt;execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 关闭</span><br><span class="line">     */</span><br><span class="line">    public function pressOff()</span><br><span class="line">    &#123;</span><br><span class="line">        foreach ($this-&gt;offCommand as $command) &#123;</span><br><span class="line">            $command-&gt;execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在来实现一下打开和关闭电灯<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$light = new Light();</span><br><span class="line">$lightOnCommand = new LightOnCommand($light);</span><br><span class="line">$lightOffCommand = new LightOffCommand($light);</span><br><span class="line">$remoteControl = new RemoteControl();</span><br><span class="line">$remoteControl-&gt;setCommand(0, $lightOnCommand, $lightOffCommand);</span><br><span class="line">$remoteControl-&gt;pressOn();</span><br><span class="line">$remoteControl-&gt;pressOff();</span><br></pre></td></tr></table></figure></p><p>当需要遥控器控制电视的时候：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$remoteControl = new RemoteControl();</span><br><span class="line">// 电灯</span><br><span class="line">$light = new Light();</span><br><span class="line">$lightOnCommand = new LightOnCommand($light);</span><br><span class="line">$lightOffCommand = new LightOffCommand($light);</span><br><span class="line">$remoteControl-&gt;setCommand(0, $lightOnCommand, $lightOffCommand);</span><br><span class="line">// 电视</span><br><span class="line">$television = new Television();</span><br><span class="line">$televisionOnCommand = new TelevisionOnCommand($television);</span><br><span class="line">$televisionOffCommand = new TelevisionOffCommand($television);</span><br><span class="line">$remoteControl-&gt;setCommand(1, $televisionOnCommand, $televisionOffCommand);</span><br><span class="line">// 打开</span><br><span class="line">$remoteControl-&gt;pressOn();</span><br><span class="line">// 关闭</span><br><span class="line">$remoteControl-&gt;pressOff();</span><br></pre></td></tr></table></figure></p><p>这样遥控器的代码不用做任何修改，就可以添加控制更多的电器，降低了两者的耦合。</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>命令模式可以用于 <strong>队列请求</strong>，<br>比如有一个工作队列，在一端添加命令，另一端取出命令调用它的execute()方法，执行完成后再去取下一个命令</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>命令模式将发出请求的对象和执行请求的对象解耦</li><li>在被解耦的两者之间是通过命令对象进行沟通的。命令对象封装了接收者的一个或一组动作</li><li>调用者可以接受命令当作参数，甚至在运行时动态的进行</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;将“请求”封装成命令对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操做。&lt;/p&gt;
&lt;h2 id=&quot;适用场景&quot;
      
    
    </summary>
    
      <category term="design-pattern" scheme="https://kris0923.github.io/categories/design-pattern/"/>
    
    
      <category term="design-pattern" scheme="https://kris0923.github.io/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>如何构建并发系统</title>
    <link href="https://kris0923.github.io/2019/07/17/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/"/>
    <id>https://kris0923.github.io/2019/07/17/如何构建并发系统/</id>
    <published>2019-07-17T15:10:51.000Z</published>
    <updated>2019-07-17T15:13:49.154Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文简单说明几个设计并发系统时需要考虑的问题，内容摘抄自《GO语言并发之道》</p></blockquote><h2 id="异常传递"><a href="#异常传递" class="headerlink" title="异常传递"></a>异常传递</h2><blockquote><p>异常是什么，什么时候发生，提供了哪些好处</p></blockquote><p>首先，异常需要传达几个关键信息：</p><ol><li>发生了什么：<br> 这部分异常信息包括了岁异常时间的描述。例如：磁盘已满，连接被重置，证书过期等</li><li>发生在什么时间，什么位置：<br> 异常应该包含完整的轨迹信息，从调用的启动方式开始，已异常的实例结尾。栈轨迹信息不应该被包含在异常信息中，但当需要处理栈中的异常时应该很容易被找到</li><li>对用户友好的信息：应当对展现给用户的信息进行自定义，应该只包含前两点的概述以及相关信息。对用户友好的信息是从用户的角度出发，给出一些信息，说明这些信息是否是暂时的，并且最好是一行以内的文本</li><li>告诉用户如何获取更多信息：某些情况下，用户希望知道当异常发生时具体发生了那些故障，展示给用户的异常信息应该提供一个id，利用这个id可以查到对应的详细日志，日志应该包含有完整的信息（异常的发生时间和异常时的堆栈调用）</li></ol><p>当展示给用户的信息不包含这些信息，不是出错了就是有BUG。所以异常可以分为两类：</p><ul><li>BUG</li><li>已知信息</li></ul><h2 id="超时和取消"><a href="#超时和取消" class="headerlink" title="超时和取消"></a>超时和取消</h2><h4 id="为什么要支持超时？"><a href="#为什么要支持超时？" class="headerlink" title="为什么要支持超时？"></a>为什么要支持超时？</h4><h6 id="系统饱和"><a href="#系统饱和" class="headerlink" title="系统饱和"></a>系统饱和</h6><p>如果系统已经饱和（已经达到系统处理请求的能力），希望可以返回超时，而不是花很长的时间等待响应。</p><h6 id="陈旧的数据"><a href="#陈旧的数据" class="headerlink" title="陈旧的数据"></a>陈旧的数据</h6><p>数据通常有一个窗口期，一般是在这个窗口中先处理更多相关数据或者处理数据的需求已经过期。<br>如果知道窗口期，那么将context.WithDeadline或context.WithTimeout创建的context传递给并发进程是有意义的，如果事先不知道窗口，我们希望并发进程的父节点能够在不再需要时取消并发进程。context.WithCancel是达到这个目的的最佳选择</p><h6 id="试图防止死锁"><a href="#试图防止死锁" class="headerlink" title="试图防止死锁"></a>试图防止死锁</h6><p>通过设置超时可以将一个死锁系统转变为一个活锁系统，在系统死锁后，很可能会遇到时序配置不同步的情况。因此最好是在允许饿时间内修复活锁，好过发生死锁后只能通过重启系统才能恢复系统</p><blockquote><p>这不是如何正确构建系统的建议，而是如何建立一个对时间问题有容错能力的系统</p></blockquote><h4 id="什么时候应当设置超时"><a href="#什么时候应当设置超时" class="headerlink" title="什么时候应当设置超时"></a>什么时候应当设置超时</h4><ul><li>请求在超时时不太可能重复</li><li>没有资源来存储请求</li><li>对系统的响应或请求发送数据有时效性要求</li></ul><h4 id="并发进程可能被取消的原因"><a href="#并发进程可能被取消的原因" class="headerlink" title="并发进程可能被取消的原因"></a>并发进程可能被取消的原因</h4><ul><li>超时-隐式取消</li><li>用户干预</li><li>父进程取消：如果父进程停止，那子进程也将被取消</li><li>复制请求：将数据发送给多个并发进程，以尝试从其中一个系统获得更快的响应。当第一个响应回来的时候，取消其余的进程。</li></ul><h2 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h2><p>心跳是并发进程向外界发出信号的一种方式。</p><h4 id="心跳类型"><a href="#心跳类型" class="headerlink" title="心跳类型"></a>心跳类型</h4><ul><li>在一段时间间隔内发出的心跳</li><li>在工作单元开始时发出的心跳</li></ul><p>golang通过channel发送心跳的时候，需要注意有可能没有人接收发出去的心跳（因为心跳不一定重要）</p><h2 id="复制请求"><a href="#复制请求" class="headerlink" title="复制请求"></a>复制请求</h2><p>某些情况下，可以将请求分发到多个处理程序（goroutine，进程，或者服务器均可），其中一个将比其他程序更快的返回结果，这样就可以立即返回结果。但是会消耗更多的资源。当多个处理程序需要多个进程，服务器，或者数据中心时，代价会相当昂贵，所以要权衡是否值得这么做</p><h2 id="速率限制"><a href="#速率限制" class="headerlink" title="速率限制"></a>速率限制</h2><h4 id="为什么需要速率限制"><a href="#为什么需要速率限制" class="headerlink" title="为什么需要速率限制"></a>为什么需要速率限制</h4><p>通常对系统进行限速，可以避免系统被攻击，如果恶意用户在资源允许的情况下可以频繁访问系统，他们可以做各种事情。比如：使用日志或有效请求打满服务器磁盘，或者DDos攻击。<br>速率限制可以将系统的性能和稳定性平衡在可控范围内</p><h4 id="如何限速"><a href="#如何限速" class="headerlink" title="如何限速"></a>如何限速</h4><p>大多数是基于令牌桶算法的，相对容易实现。golang中 golang.org/x/time/rate <a href="https://github.com/golang/time" target="_blank" rel="noopener">[github 地址]</a> 包实现了这个功能</p><h2 id="治愈异常的goroutine"><a href="#治愈异常的goroutine" class="headerlink" title="治愈异常的goroutine"></a>治愈异常的goroutine</h2><p>在一个长期运行的程序中，建立一个机制来监控你的goroutine是否处于健康状态是很有用的，当goroutine异常时，可以尽快的重启。重启的过程成为“治愈”（Healing）。</p><h4 id="如何治愈goroutine？"><a href="#如何治愈goroutine？" class="headerlink" title="如何治愈goroutine？"></a>如何治愈goroutine？</h4><p>使用心跳模式检查我们正在监控的goroutine是否活跃。我们需要一个管理员来监视一个管理区的goroutine，如果有goroutine变得不健康，管理员负责重启这个管理区的goroutine。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文简单说明几个设计并发系统时需要考虑的问题，内容摘抄自《GO语言并发之道》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;异常传递&quot;&gt;&lt;a href=&quot;#异常传递&quot; class=&quot;headerlink&quot; title=&quot;异常传递&quot;&gt;&lt;/a&gt;异
      
    
    </summary>
    
      <category term="go" scheme="https://kris0923.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://kris0923.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>MySql 修改表结构时 ALTER,MODIFY,CHANGE的区别</title>
    <link href="https://kris0923.github.io/2019/07/17/MySql-%E4%BF%AE%E6%94%B9%E8%A1%A8%E7%BB%93%E6%9E%84%E6%97%B6-ALTER-MODIFY-CHANGE%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://kris0923.github.io/2019/07/17/MySql-修改表结构时-ALTER-MODIFY-CHANGE的区别/</id>
    <published>2019-07-17T15:09:55.000Z</published>
    <updated>2019-07-17T15:13:44.767Z</updated>
    
    <content type="html"><![CDATA[<p>根据MySql文档，我们知道在修改表内某一列的属性的时候，MySql支持3中语法结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER [ONLINE|OFFLINE] [IGNORE] TABLE tbl_name  </span><br><span class="line">ALTER [COLUMN] col_name &#123;SET DEFAULT literal | DROP DEFAULT&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER [ONLINE|OFFLINE] [IGNORE] TABLE tbl_name  </span><br><span class="line">CHANGE [COLUMN] old_col_name new_col_name column_definition [FIRST|AFTER col_name]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER [ONLINE|OFFLINE] [IGNORE] TABLE tbl_name </span><br><span class="line">MODIFY [COLUMN] col_name column_definition [FIRST | AFTER col_name]</span><br></pre></td></tr></table></figure><p>这里比较一下这三种语法的不同之处，以及什么情况下应该选用什么语法</p><table><thead><tr><th>语法</th><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>ALTER</td><td>只能更改列的默认值</td><td></td></tr><tr><td>CHANGE</td><td>可以重命名列或者修改列的定义</td><td>标准SQL的扩展</td></tr><tr><td>MODIFY</td><td>可以更改列的定义，但不能更改列的名称</td><td>兼容Oracle的扩展</td></tr></tbody></table><p>通过文档介绍的功能，我们就基本能够判断处该使用使用哪种语法，CHANGE功能最强大，什么情况下都可以使用(达到预期的效果)。但是还有一个区别：</p><ul><li>ALTER 语法只是修改 .frm 文件，不会去更新表中的数据；</li><li>MODIFY和CHANGE在更新表结构的时候重新插入表中的数据，因此比较耗费时间。</li></ul><p>所以，当只需要修改某一列的默认值的时候，优先选择用ALTER，需要修改列的名称用CHANGE，只修改列的定义用MIODIFY</p><blockquote><p>如果修改的列上有索引，修改完后最好重建一下索引</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;根据MySql文档，我们知道在修改表内某一列的属性的时候，MySql支持3中语法结构：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/
      
    
    </summary>
    
      <category term="mysql" scheme="https://kris0923.github.io/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://kris0923.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Laravel Facades 门面模式的实现</title>
    <link href="https://kris0923.github.io/2019/07/17/Laravel-Facades-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://kris0923.github.io/2019/07/17/Laravel-Facades-门面模式的实现/</id>
    <published>2019-07-17T15:08:42.000Z</published>
    <updated>2019-07-17T15:13:38.848Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以下是Laravel官方文档的介绍</p></blockquote><p>Facades 为应用程序的 服务容器 中可用的类提供了一个「静态」接口。Laravel 本身附带许多的 facades，甚至你可能在不知情的状况下已经在使用他们！Laravel 「facades」作为在服务容器内基类的「静态代理」，拥有简洁、易表达的语法优点，同时维持着比传统静态方法更高的可测试性和灵活性。</p><p>从介绍中可以看出，Facades 好处就是让代码更加简介，优雅，这也是Laravel追求的特性，如何使用Facades这里就不介绍了，可以参考<a href="https://learnku.com/docs/laravel/5.2/facades/1111" target="_blank" rel="noopener">Laravel文档(中文)</a> ，本文介绍一下Facades是如何知道和创建你需要的类实例。</p><p>以 log Facade 为例，我们看下是如何通过log这个字符串找到 \Illuminate\Log\Writer 这个类的<br>先看 \Illuminate\Support\Facades\Log 门面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Log extends Facade</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * Get the registered name of the component.</span><br><span class="line">     *</span><br><span class="line">     * @return string</span><br><span class="line">     */</span><br><span class="line">    protected static function getFacadeAccessor()</span><br><span class="line">    &#123;</span><br><span class="line">        return &apos;log&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个类非常简单，只有一个静态方法 getFacadeAccessor(), 返回了一个log字符串。<br>然后看Log的父类 Facade, Facede中有很多方法，这里关注其中两个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">abstract class Facade</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * The application instance being facaded.</span><br><span class="line">     *</span><br><span class="line">     * @var \Illuminate\Contracts\Foundation\Application</span><br><span class="line">     */</span><br><span class="line">    protected static $app;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The resolved object instances.</span><br><span class="line">     *</span><br><span class="line">     * @var array</span><br><span class="line">     */</span><br><span class="line">    protected static $resolvedInstance;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * Resolve the facade root instance from the container.</span><br><span class="line">     *</span><br><span class="line">     * @param  string|object  $name</span><br><span class="line">     * @return mixed</span><br><span class="line">     */</span><br><span class="line">    protected static function resolveFacadeInstance($name)</span><br><span class="line">    &#123;</span><br><span class="line">        if (is_object($name)) &#123;// 如果$name已经是一个对象，则直接返回该对象</span><br><span class="line">            return $name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (isset(static::$resolvedInstance[$name])) &#123;// 如果是已经解析过的对象，直接从$resolvedInstance中返回该对象</span><br><span class="line">            return static::$resolvedInstance[$name];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return static::$resolvedInstance[$name] = static::$app[$name];  // 从容器中寻找$name对象，并放入$resolvedInstance 中以便下次使用</span><br><span class="line">    &#125;</span><br><span class="line">/**</span><br><span class="line">     * Handle dynamic, static calls to the object.</span><br><span class="line">     *</span><br><span class="line">     * @param  string  $method</span><br><span class="line">     * @param  array   $args</span><br><span class="line">     * @return mixed</span><br><span class="line">     *</span><br><span class="line">     * @throws \RuntimeException</span><br><span class="line">     */</span><br><span class="line">    public static function __callStatic($method, $args)// 魔术方法，当使用Log::error($msg) 的时候会调用该方法</span><br><span class="line">    &#123;</span><br><span class="line">        $instance = static::getFacadeRoot();</span><br><span class="line"></span><br><span class="line">        if (! $instance) &#123;</span><br><span class="line">            throw new RuntimeException(&apos;A facade root has not been set.&apos;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        switch (count($args)) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                return $instance-&gt;$method();</span><br><span class="line">            case 1:</span><br><span class="line">                return $instance-&gt;$method($args[0]);</span><br><span class="line">            case 2:</span><br><span class="line">                return $instance-&gt;$method($args[0], $args[1]);</span><br><span class="line">            case 3:</span><br><span class="line">                return $instance-&gt;$method($args[0], $args[1], $args[2]);</span><br><span class="line">            case 4:</span><br><span class="line">                return $instance-&gt;$method($args[0], $args[1], $args[2], $args[3]);</span><br><span class="line">            default:</span><br><span class="line">                return call_user_func_array([$instance, $method], $args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过以上分析知道最终Facede找的是容器中绑定的实例，所以接下来我们找一下log是在什么时候被注册的，</p><p>这时候需要关注 \Illuminate\Foundation\Http\Kernel 类,Kernel类中包括以下几个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Handle an incoming HTTP request.</span><br><span class="line">*</span><br><span class="line">* @param  \Illuminate\Http\Request  $request</span><br><span class="line">* @return \Illuminate\Http\Response</span><br><span class="line">*/</span><br><span class="line">public function handle($request)</span><br><span class="line">&#123;</span><br><span class="line">try &#123;</span><br><span class="line">$request-&gt;enableHttpMethodParameterOverride();</span><br><span class="line"></span><br><span class="line">$response = $this-&gt;sendRequestThroughRouter($request);</span><br><span class="line">&#125; catch (Exception $e) &#123;</span><br><span class="line">$this-&gt;reportException($e);</span><br><span class="line"></span><br><span class="line">$response = $this-&gt;renderException($request, $e);</span><br><span class="line">&#125; catch (Throwable $e) &#123;</span><br><span class="line">$this-&gt;reportException($e = new FatalThrowableError($e));</span><br><span class="line"></span><br><span class="line">$response = $this-&gt;renderException($request, $e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$this-&gt;app[&apos;events&apos;]-&gt;fire(&apos;kernel.handled&apos;, [$request, $response]);</span><br><span class="line"></span><br><span class="line">return $response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Send the given request through the middleware / router.</span><br><span class="line">*</span><br><span class="line">* @param  \Illuminate\Http\Request  $request</span><br><span class="line">* @return \Illuminate\Http\Response</span><br><span class="line">*/</span><br><span class="line">protected function sendRequestThroughRouter($request)</span><br><span class="line">&#123;</span><br><span class="line">$this-&gt;app-&gt;instance(&apos;request&apos;, $request);</span><br><span class="line"></span><br><span class="line">Facade::clearResolvedInstance(&apos;request&apos;);</span><br><span class="line"></span><br><span class="line">$this-&gt;bootstrap();</span><br><span class="line"></span><br><span class="line">return (new Pipeline($this-&gt;app))</span><br><span class="line">-&gt;send($request)</span><br><span class="line">-&gt;through($this-&gt;app-&gt;shouldSkipMiddleware() ? [] : $this-&gt;middleware)</span><br><span class="line">-&gt;then($this-&gt;dispatchToRouter());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Bootstrap the application for HTTP requests.</span><br><span class="line">*</span><br><span class="line">* @return void</span><br><span class="line">*/</span><br><span class="line">public function bootstrap()</span><br><span class="line">&#123;</span><br><span class="line">if (! $this-&gt;app-&gt;hasBeenBootstrapped()) &#123;</span><br><span class="line">$this-&gt;app-&gt;bootstrapWith($this-&gt;bootstrappers());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>handle方法接收一个Request请求，并返回一个$response，$response-&gt;sendRequestThroughRouter()的时候调用了bootstrap()方法，继续看bootstrap方法里面加载了已经定义好的几个类：(这些定义都在Kernel类中)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* The bootstrap classes for the application.</span><br><span class="line">*</span><br><span class="line">* @var array</span><br><span class="line">*/</span><br><span class="line">protected $bootstrappers = [</span><br><span class="line">&apos;Illuminate\Foundation\Bootstrap\DetectEnvironment&apos;,</span><br><span class="line">&apos;Illuminate\Foundation\Bootstrap\LoadConfiguration&apos;,</span><br><span class="line">&apos;Illuminate\Foundation\Bootstrap\ConfigureLogging&apos;,</span><br><span class="line">&apos;Illuminate\Foundation\Bootstrap\HandleExceptions&apos;,</span><br><span class="line">&apos;Illuminate\Foundation\Bootstrap\RegisterFacades&apos;,</span><br><span class="line">&apos;Illuminate\Foundation\Bootstrap\RegisterProviders&apos;,</span><br><span class="line">&apos;Illuminate\Foundation\Bootstrap\BootProviders&apos;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>然后我们看ConfigureLogging中的registerLogger()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Register the logger instance in the container.</span><br><span class="line">*</span><br><span class="line">* @param  \Illuminate\Contracts\Foundation\Application  $app</span><br><span class="line">* @return \Illuminate\Log\Writer</span><br><span class="line">*/</span><br><span class="line">protected function registerLogger(Application $app)</span><br><span class="line">&#123;</span><br><span class="line">$app-&gt;instance(&apos;log&apos;, $log = new Writer( // 这里把Writer注册到了容器中</span><br><span class="line">new Monolog($app-&gt;environment()), $app[&apos;events&apos;])</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">return $log;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到此为止，我们已经知道Facede是如何找到想要使用的类了。<br>Facedes看起来挺高大上，但实现起来的原理挺简单的，实际上也是一种单例模式，只不过在调用处包装了一下</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;以下是Laravel官方文档的介绍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Facades 为应用程序的 服务容器 中可用的类提供了一个「静态」接口。Laravel 本身附带许多的 facades，甚至你可能在不知情的状况下已经在使用他们！Lar
      
    
    </summary>
    
      <category term="php" scheme="https://kris0923.github.io/categories/php/"/>
    
    
      <category term="php" scheme="https://kris0923.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成</title>
    <link href="https://kris0923.github.io/2019/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    <id>https://kris0923.github.io/2019/07/17/计算机组成/</id>
    <published>2019-07-17T14:50:45.000Z</published>
    <updated>2019-07-18T00:06:52.770Z</updated>
    
    <content type="html"><![CDATA[<ul><li>运算器</li><li>控制器</li><li>存储器</li><li>输入输出设备</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;运算器&lt;/li&gt;
&lt;li&gt;控制器&lt;/li&gt;
&lt;li&gt;存储器&lt;/li&gt;
&lt;li&gt;输入输出设备&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
      <category term="computer-science" scheme="https://kris0923.github.io/categories/computer-science/"/>
    
    
      <category term="computer-science" scheme="https://kris0923.github.io/tags/computer-science/"/>
    
  </entry>
  
  <entry>
    <title>校验码</title>
    <link href="https://kris0923.github.io/2019/07/17/%E6%A0%A1%E9%AA%8C%E7%A0%81/"/>
    <id>https://kris0923.github.io/2019/07/17/校验码/</id>
    <published>2019-07-17T04:18:45.000Z</published>
    <updated>2019-07-17T06:13:03.455Z</updated>
    
    <content type="html"><![CDATA[<p>为了保证计算机系统运行时数据在传输过程中正确无误，提高硬件电路的可靠性和提高代码的校验能力,通常使用校验码来检测传输数据是否出错，常用的3种校验码：</p><h4 id="1-奇偶校验"><a href="#1-奇偶校验" class="headerlink" title="1. 奇偶校验"></a>1. 奇偶校验</h4><ul><li>专门设置一个奇偶校验位来保证发出数据中的1的个数是奇数（或者偶数)，</li><li>缺点:只能发现有奇数个位出错的情况，不能发现有偶数个位出错的情况<h4 id="2-海明码校验"><a href="#2-海明码校验" class="headerlink" title="2. 海明码校验"></a>2. 海明码校验</h4>在数据的特定位置上插入 k 个校验位,假设原来的数据有n位，这样编码后的数据有n+k位，数据就会有n+k位出错和一种正确情况，所以k应该满足：<br>2^k - 1 &gt;= n+k </li></ul><ul><li>检验码的位置都在数据的2^m位上</li><li>校验码的每一个值可以表示一位数据是否正确</li><li>将每个海明码出现的位置做异或运算，得到的结果就是出错的位置-进行取反操作<h4 id="3-循环冗余码校验"><a href="#3-循环冗余码校验" class="headerlink" title="3. 循环冗余码校验"></a>3. 循环冗余码校验</h4>广泛用于数据通信领域和磁介质存储系统中.<h5 id="循环冗余校验码原理："><a href="#循环冗余校验码原理：" class="headerlink" title="循环冗余校验码原理："></a>循环冗余校验码原理：</h5></li><li>发送端和接收端共同设置一个除数（生成多项式），通常最高位和最低位都是1，或者公式 G(x) = 2^x + 2^(x-1) + 1</li><li>在原数据后面添加n个校验位，n=除数的位数 -1 (校验位上存的是余数，所以不会比除数大)</li><li>发送端用原数据补充n-1个0后，对多项式进行模2运算，将余数放到校验位上</li><li>接收端用接收到的数据和多项式也进行模2运算，如果余数伟0，则数据正确，否则数据错误，需要发送端重传</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了保证计算机系统运行时数据在传输过程中正确无误，提高硬件电路的可靠性和提高代码的校验能力,通常使用校验码来检测传输数据是否出错，常用的3种校验码：&lt;/p&gt;
&lt;h4 id=&quot;1-奇偶校验&quot;&gt;&lt;a href=&quot;#1-奇偶校验&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="computer-science" scheme="https://kris0923.github.io/categories/computer-science/"/>
    
    
      <category term="computer-science" scheme="https://kris0923.github.io/tags/computer-science/"/>
    
  </entry>
  
  <entry>
    <title>PHP5与PHP7的zval比较</title>
    <link href="https://kris0923.github.io/2019/07/17/PHP5%E4%B8%8EPHP7%E7%9A%84zval%E6%AF%94%E8%BE%83/"/>
    <id>https://kris0923.github.io/2019/07/17/PHP5与PHP7的zval比较/</id>
    <published>2019-07-17T04:16:53.000Z</published>
    <updated>2019-07-17T06:03:54.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PHP5中zval定义"><a href="#PHP5中zval定义" class="headerlink" title="PHP5中zval定义"></a>PHP5中zval定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zval</span> <span class="title">struct</span> &#123;</span></span><br><span class="line">    zvalue_value value; <span class="comment">// 16</span></span><br><span class="line">    zend_unit refcount_gc; <span class="comment">// 4字节 引用计数</span></span><br><span class="line">    zend_uchar type;        <span class="comment">// 1 </span></span><br><span class="line">    zend_uchar is_ref__gc; <span class="comment">// 1 是否为引用类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> _avalue_value &#123;</span><br><span class="line">    <span class="keyword">long</span> lval; <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">double</span> dval; <span class="comment">// 8</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> *val;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">    &#125; str; <span class="comment">// 16</span></span><br><span class="line">    HashTable *ht; <span class="comment">// HashTable 数组 8</span></span><br><span class="line">    zend_object_value obj; <span class="comment">// 12</span></span><br><span class="line">    zend_ast * ast; <span class="comment">// 8</span></span><br><span class="line">&#125; zvalue_value;</span><br></pre></td></tr></table></figure><p>为了解决<em>循环引用问题</em>，PHP5.3之后通过重写分配zval的宏，对zval进行扩充，新的分配方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#undef ALLOC_ZVAL</span><br><span class="line">#define ALLOC_ZVAL (z)</span><br><span class="line">    do &#123;</span><br><span class="line">        (z) = (zval*) emalloc (sizeof(zval_gc_info));</span><br><span class="line">        GC_ZVAL_INT (z);</span><br><span class="line">    &#125; while(0)</span><br><span class="line"></span><br><span class="line">// _zval_gc_info 结构如下：</span><br><span class="line">typedef struct _zval_gc_info &#123;</span><br><span class="line">    zval z;</span><br><span class="line">    union &#123;</span><br><span class="line">        gc_root_buffer *buffer;</span><br><span class="line">        struct _zval_gc_info *next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除此之外，在开启Zend内存池的情况下，zval_gc_info 在内存池中分配，内存池会为每个zval_gc_info额外申请一个大小为16字节的zend_mm_block结构体，用来存放内存相关信息，zend_mm_block结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _zend_mm_block_info &#123;</span><br><span class="line">    size_t _size;</span><br><span class="line">    size_t _prev;</span><br><span class="line">&#125; zend_mm_block_info;</span><br><span class="line">typedef struct _zend_mm_block &#123;</span><br><span class="line">    zend_mm_block_info info;</span><br><span class="line">&#125; zend_mm_block;</span><br></pre></td></tr></table></figure></p><p>最终一个变量在PHP5中占内存大小为48个字节（48个字节其实有很多浪费），占用情况如图：</p><blockquote><p>1.zend_mm_block 是啥<br>2.为什么会有循环引用的问题</p></blockquote><h2 id="PHP7的zval"><a href="#PHP7的zval" class="headerlink" title="PHP7的zval"></a>PHP7的zval</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">typedef union _zend_value &#123;</span><br><span class="line">zend_long         lval;/* long value */</span><br><span class="line">double            dval;/* double value */</span><br><span class="line">zend_refcounted  *counted; // 引用计数</span><br><span class="line">zend_string      *str;</span><br><span class="line">zend_array       *arr;</span><br><span class="line">zend_object      *obj;</span><br><span class="line">zend_resource    *res;</span><br><span class="line">zend_reference   *ref;</span><br><span class="line">zend_ast_ref     *ast;</span><br><span class="line">zval             *zv;</span><br><span class="line">void             *ptr;</span><br><span class="line">zend_class_entry *ce;</span><br><span class="line">zend_function    *func;</span><br><span class="line">struct &#123;</span><br><span class="line">uint32_t w1;</span><br><span class="line">uint32_t w2;</span><br><span class="line">&#125; ww;</span><br><span class="line">&#125; zend_value;</span><br><span class="line"></span><br><span class="line">struct _zval_struct &#123;</span><br><span class="line">zend_value        value;/* value */</span><br><span class="line">union &#123;</span><br><span class="line">struct &#123;</span><br><span class="line">ZEND_ENDIAN_LOHI_4(</span><br><span class="line">zend_uchar    type,/* active type 记录变量类型*/</span><br><span class="line">zend_uchar    type_flags,</span><br><span class="line">zend_uchar    const_flags,</span><br><span class="line">zend_uchar    reserved)    /* call info for EX(This) */</span><br><span class="line">&#125; v; /* 4字节 */</span><br><span class="line">uint32_t type_info; // 4字节 其实type_info 就是v 中4个char的组合</span><br><span class="line">&#125; u1;</span><br><span class="line">union &#123;</span><br><span class="line">uint32_t     next;                 /* hash collision chain */</span><br><span class="line">uint32_t     cache_slot;           /* literal cache slot */</span><br><span class="line">uint32_t     lineno;               /* line number (for ast nodes) */</span><br><span class="line">uint32_t     num_args;             /* arguments number for EX(This) */</span><br><span class="line">uint32_t     fe_pos;               /* foreach position */</span><br><span class="line">uint32_t     fe_iter_idx;          /* foreach iterator index */</span><br><span class="line">uint32_t     access_flags;         /* class constant access flags */</span><br><span class="line">uint32_t     property_guard;       /* single property guard 单一属性保护*/</span><br><span class="line">uint32_t     extra;                /* not further specified 保留字段，暂无意义*/</span><br><span class="line">&#125; u2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>PHP7的zval中value占8字节，u1占4字节，u2为辅助字段，占4字节，这样zval一共占16字节，即使没有u2，在内存对齐的情况下，zval也要占16字节，用u2记录了一些特殊信息，并不会浪费内存，反而是对内存的充分利用</p><p>PHP7 Z_VAL内存占用图<br><img src="https://github.com/kris0923/kris0923.github.io/blob/master/images/php_z_val.png" alt="php7_z_val"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;PHP5中zval定义&quot;&gt;&lt;a href=&quot;#PHP5中zval定义&quot; class=&quot;headerlink&quot; title=&quot;PHP5中zval定义&quot;&gt;&lt;/a&gt;PHP5中zval定义&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
    
      <category term="php" scheme="https://kris0923.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>GO语言语法基础</title>
    <link href="https://kris0923.github.io/2018/12/09/GO%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://kris0923.github.io/2018/12/09/GO 基础语法/</id>
    <published>2018-12-09T11:42:24.000Z</published>
    <updated>2018-12-09T12:03:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><ol><li>i++, i– 在go语言中是语句，而不像其他语言一样是表达式，所以， j = i++ 在go语言里面是不合法的,并且只支持后缀， –i 是不合法的</li><li><p>for 是go里面唯一的循环语句<br> 传统的while循环写成<br> for condition {</p><p> }</p></li><li><p>函数 </p><p> 函数的类型，称为函数签名，函数的实参都是按值传递的</p></li><li><p>文件结束标示</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">err = errors.New(&quot;EOF&quot;)</span><br><span class="line">in := bufio.NewReader(os.stdin)</span><br><span class="line">for &#123;</span><br><span class="line">    r,_,err = in.ReadRune()</span><br><span class="line">    if err == io.EOF &#123;</span><br><span class="line">        break // 文本结束标记</span><br><span class="line">    &#125;</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return fmt.Errorf(&quot;read failed: $v&quot;,err)</span><br><span class="line">    &#125;</span><br><span class="line">    // 处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> go 文本结束标记不怎么友好，为什么要放到error信息中</p></li><li><p>数组<br> Go 语言中的数组是一种 <strong>值类型</strong>（不像 C/C++ 中是指向首元素的指针），所以可以通过 new() 来创建： var arr1 = new([5]int)。</p><p> 那么这种方式和 var arr2 [5]int 的区别是什么呢？arr1 的类型是 *[5]int，而 arr2的类型是 [5]int。</p><p> 这样的结果就是当把一个数组赋值给另一个时，需要在做一次数组内存的拷贝操作。例如：</p><p> arr2 := *arr1<br> arr2[2] = 100<br> 这样两个数组就有了不同的值，在赋值后修改 arr2 不会对 arr1 生效。</p><p> ==切片是引用类型，所以不能用指针指向切片==    </p></li><li><p>参数传递<br> go中所有的东西都是按值传递的，每次调用函数时，传入的数据都会被复制。对于具有值接收者的方法，在调用该方法时将复制该值。因为所有的参数都是通过值传递的，这就可以解释为什么 <em>Cat 的方法不能被 Cat 类型的值调用了。任何一个  Cat 类型的值可能会有很多 </em>Cat 类型的指针指向它，如果我们尝试通过 Cat 类型的值来调用 *Cat 的方法，根本就不知道对应的是哪个指针。</p><h1 id="go-并发编程"><a href="#go-并发编程" class="headerlink" title="go 并发编程"></a>go 并发编程</h1><ol><li><p>goroutine 和通道</p><p> 程序启动时，只有一个 goroutine 来调用 main 函数，称为主 goroutine，新的 goroutine 通过 go 语句创建<br>，就是在普通的函数或方法前加上 go 关键字，当 main 函数返回时，所有的 goroutine 都将暴力终止。  </p></li><li><p>缓冲通道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func mirroredQuery() string&#123;</span><br><span class="line">    responses := make(chan string,3)</span><br><span class="line">    go func() &#123;responses &lt;- request(&quot;asia.gopl.io&quot;)&#125;()</span><br><span class="line">    go func() &#123;responses &lt;- request(&quot;europe.gopl.io&quot;)&#125;()</span><br><span class="line">    go func() &#123;responses &lt;- request(&quot;americas.gopl.io&quot;)&#125;()</span><br><span class="line">    return &lt;-responses //return the questest response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主goroutine只接收第一个返回的，或者极端情况下，两个较慢的服务器还没有返回响应，就返回了结果</p></li><li>goroutine 泄漏<br> 如果使用无缓冲通道，两个较慢的通道goroutine将被卡住（因为他们发送响应结果到通道没有goroutine来接收），这种情况叫goroutine泄漏。不要通过共享内存来通信，应该通过通信来共享内存</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      主要记录与传统语言不同之处
    
    </summary>
    
      <category term="go" scheme="https://kris0923.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://kris0923.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>PHP 内核分析笔记（二）多进程与多线程SAPI生命周期</title>
    <link href="https://kris0923.github.io/2018/12/08/PHP%20%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://kris0923.github.io/2018/12/08/PHP 内核分析笔记（二）/</id>
    <published>2018-12-08T10:08:48.000Z</published>
    <updated>2019-07-17T06:03:38.853Z</updated>
    
    <content type="html"><![CDATA[<h3 id="多进程SAPI生命周期"><a href="#多进程SAPI生命周期" class="headerlink" title="多进程SAPI生命周期"></a>多进程SAPI生命周期</h3><p>以Apache为例，PHP编译为apache的一个模块来处理php请求，Apache启动后会fork多个进程，每个进程拥有独立的内存空间，单独处理php请求，所以每个子进程都是完整的生命周期<br><img src="http://www.php-internals.com/images/book/chapt02/02-01-02-multiprocess-life-cycle.png" alt="img"></p><h3 id="多线程的SAPI生命周期"><a href="#多线程的SAPI生命周期" class="headerlink" title="多线程的SAPI生命周期"></a>多线程的SAPI生命周期</h3><p>同一组线程只有一个模块初始化和销毁的过程<br><img src="http://www.php-internals.com/images/book/chapt02/02-01-013-multithreaded-lift-cycle.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      深入理解PHP内核阅读笔记
    
    </summary>
    
      <category term="php" scheme="https://kris0923.github.io/categories/php/"/>
    
    
      <category term="php" scheme="https://kris0923.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>PHP 内核分析笔记（一）单进程SAPI生命周期</title>
    <link href="https://kris0923.github.io/2018/12/08/PHP%20%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://kris0923.github.io/2018/12/08/PHP 内核分析笔记（一）/</id>
    <published>2018-12-08T03:55:54.000Z</published>
    <updated>2019-07-17T06:03:48.083Z</updated>
    
    <content type="html"><![CDATA[<p><inernal class="png"><a href="http://www.php-internals.com/images/book/chapt02/02-00-php-" target="_blank" rel="noopener">http://www.php-internals.com/images/book/chapt02/02-00-php-</a></inernal></p><h3 id="单进程SAPI生命周期"><a href="#单进程SAPI生命周期" class="headerlink" title="单进程SAPI生命周期"></a>单进程SAPI生命周期</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">:start</span><br><span class="line">    php -f test.php</span><br><span class="line">        call each extension`s MINIT (模块初始化阶段，调用所有模块的MINIT函数)</span><br><span class="line">            Request test.php</span><br><span class="line">                call each extension`s RINIT (调用所有模块的RINIT函数)</span><br><span class="line">                    Execute test.php</span><br><span class="line">                call each extension`s RSHUTDOWM</span><br><span class="line">            Finsh cleaning up after test.php</span><br><span class="line">        call each extension`s MSHUTDOWM （Web服务器退出或者命令行脚本执行完毕退出）</span><br><span class="line">    terminate test.php</span><br><span class="line">:end</span><br></pre></td></tr></table></figure><h3 id="启动-模块初始化阶段"><a href="#启动-模块初始化阶段" class="headerlink" title="启动 模块初始化阶段"></a>启动 模块初始化阶段</h3><ul><li>初始化若干全局变量</li><li>初始化若干常量，这里的常量是PHP自己的一些常量，如PHP_VERSION</li><li>初始化Zend引擎和核心组件</li><li>解析php.ini</li><li>全局操作函数的初始化</li><li>初始化静态构建的模块和共享模块(MINIT)</li><li>禁用函数和类 php_disable_functions, 其禁用的过程是调用zend_disable_function函数将指定的函数名从CG(function_table)函数表中删除,php_disable_classes,将指定的类名从CG(class_table)类表中删除</li></ul><h3 id="ACTIVATION"><a href="#ACTIVATION" class="headerlink" title="ACTIVATION"></a>ACTIVATION</h3><ul><li>激活Zend引擎</li><li>激活SAPI</li><li>环境初始化<br>这里的环境初始化是指在用户空间中需要用到的一些环境变量初始化，这里的环境包括服务器环境、请求数据环境等。 实际到我们用到的变量，就是$_POST、$_GET、$_COOKIE、$_SERVER、$_ENV、$_FILES。 和sapi_module.default_post_reader一样，sapi_module.treat_data的值也是在模块初始化时， 通过php_startup_sapi_content_types函数注册了默认数据处理函数为main/php_variables.c文件中php_default_treat_data函数</li><li>模块请求初始化 (Call each extension’s RINIT)<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3></li><li>php_execute_script 函数包含了运行PHP脚本的全部过程<h3 id="DEACTIVATION"><a href="#DEACTIVATION" class="headerlink" title="DEACTIVATION"></a>DEACTIVATION</h3>  PHP关闭请求的过程是一个若干个关闭操作的集合，这个集合存在于php_request_shutdown函数中<ol><li>调用所有通过register_shutdown_function()注册的函数</li><li>执行所有可用的__destruct函数</li><li>将所有的输出刷出去</li><li>发送HTTP应答头</li><li>遍历每个模块的关闭请求方法 call each extension`s RSHUTDOWM</li><li>销毁全局变量表（PG(http_globals)）的变量</li><li>通过zend_deactivate函数，关闭词法分析器、语法分析器和中间代码执行器</li><li>调用每个扩展的post-RSHUTDOWN函数</li><li>关闭SAPI，通过sapi_deactivate销毁SG(sapi_headers)、SG(request_info)等的内容</li><li>关闭流的包装器、关闭流的过滤器</li><li>关闭内存管理</li><li>重新设置最大执行时间<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3></li></ol></li><li>flush</li><li>关闭Zend引擎</li><li>在关闭所有的模块后，PHP继续销毁全局函数表，销毁全局类表、销售全局变量表等。 通过zend_shutdown_extensions遍历zend_extensions所有元素，调用每个扩展的shutdown函数</li></ul>]]></content>
    
    <summary type="html">
    
      深入理解PHP内核阅读笔记
    
    </summary>
    
      <category term="php" scheme="https://kris0923.github.io/categories/php/"/>
    
    
      <category term="php" scheme="https://kris0923.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>PHP 知识总结（一）</title>
    <link href="https://kris0923.github.io/2018/09/24/php-summarize/"/>
    <id>https://kris0923.github.io/2018/09/24/php-summarize/</id>
    <published>2018-09-24T10:41:27.000Z</published>
    <updated>2019-07-17T06:04:02.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h1><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><ol><li>boolean</li><li>integet</li><li><p>float</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 判断是否是一个数值类型</span><br><span class="line">bool is_nan(float $val)</span><br></pre></td></tr></table></figure></li><li><p>string</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 字符串转数值</span><br><span class="line">//如果 字符串中包含 &apos;.&apos;, &apos;e&apos;或者&apos;E&apos; 转换为float，其余转为 int</span><br></pre></td></tr></table></figure></li><li><p>Array</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 数组的key只能是int 或string</span><br><span class="line">合法的整型字符串会被转成int，例如：&quot;8&quot;，&quot;08&quot;不会，因为08不是合法的十进制数</span><br><span class="line">浮点数也会被转换为整型，意味着其小数部分会被舍去。例如键名 8.7 实际会被储存为 8。</span><br><span class="line">布尔值也会被转换成整型。即键名 true 实际会被储存为 1 而键名 false 会被储存为 0。</span><br><span class="line">Null 会被转换为空字符串，即键名 null 实际会被储存为 &quot;&quot;。</span><br><span class="line">数组和对象不能被用为键名。坚持这么做会导致警告：Illegal offset type</span><br><span class="line">默认键： 当前最大整数索引值加1</span><br><span class="line">// 其他类型转为数组</span><br><span class="line">$a = array($a);</span><br><span class="line">or</span><br><span class="line">$a = (array) $a;</span><br><span class="line">如果一个 object 类型转换为 array，则结果为一个数组，其单元为该对象的属性。键名将为成员变量名，不过有几点例外：整数属性不可访问；私有变量前会加上类名作前缀；保护变量前会加上一个 &apos;*&apos; 做前缀。这些前缀的前后都各有一个 NULL 字符。这会导致一些不可预知的行为：</span><br><span class="line">class A &#123;</span><br><span class="line">    private $A; // This will become &apos;\0A\0A&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">    private $A; // This will become &apos;\0B\0A&apos;</span><br><span class="line">    public $AA; // This will become &apos;AA&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump((array) new B());</span><br><span class="line">//上例会有两个键名为 &apos;AA&apos;，不过其中一个实际上是 &apos;\0A\0A&apos;</span><br></pre></td></tr></table></figure></li><li><p>Object</p></li><li><p>Reource 资源类型</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">资源 resource 是一种特殊变量，保存了到外部资源的一个引用</span><br><span class="line">可以用 is_resource()函数测定一个变量是否是资源，函数 get_resource_type()则返回该资源的类型</span><br></pre></td></tr></table></figure></li><li><p>NULL</p></li><li>Callback/Callable<h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2> <a href="http://php.net/manual/zh/language.oop5.magic.php#" target="_blank" rel="noopener">http://php.net/manual/zh/language.oop5.magic.php#</a> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__construct()，</span><br><span class="line">__destruct()， </span><br><span class="line">__call()， </span><br><span class="line">__callStatic()， </span><br><span class="line">__get()， </span><br><span class="line">__set()， </span><br><span class="line">__isset()， </span><br><span class="line">__unset()， </span><br><span class="line">__sleep()， </span><br><span class="line">__wakeup()， </span><br><span class="line">__toString()， </span><br><span class="line">__invoke()， </span><br><span class="line">__set_state()， </span><br><span class="line">__clone() 和 </span><br><span class="line">__debugInfo()</span><br></pre></td></tr></table></figure></li></ol><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>算数运算符</p><p>$a <strong> $b 表示已$a的$b次方（PHP5.6之后支持）, $a </strong> $b = exp($a*log($a));</p><p>赋值运算符=</p><p>一般情况下赋值运算是将原变量的值拷贝到新变量中，但有个例外，就是碰到对象<em>object</em>时是引用赋值，除非明确使用<em>clone</em>关键字</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;语法基础&quot;&gt;&lt;a href=&quot;#语法基础&quot; class=&quot;headerlink&quot; title=&quot;语法基础&quot;&gt;&lt;/a&gt;语法基础&lt;/h1&gt;&lt;h2 id=&quot;变量类型&quot;&gt;&lt;a href=&quot;#变量类型&quot; class=&quot;headerlink&quot; title=&quot;变量类型&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="php" scheme="https://kris0923.github.io/categories/php/"/>
    
    
      <category term="php" scheme="https://kris0923.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>Mysql事务和锁</title>
    <link href="https://kris0923.github.io/2018/06/15/%E4%BB%8EHello-World%E5%BC%80%E5%A7%8B/"/>
    <id>https://kris0923.github.io/2018/06/15/从Hello-World开始/</id>
    <published>2018-06-15T14:50:45.000Z</published>
    <updated>2018-06-17T13:54:41.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是事务&quot;&gt;&lt;a href=&quot;#什么是事务&quot; class=&quot;headerlink&quot; title=&quot;什么是事务&quot;&gt;&lt;/a&gt;什么是事务&lt;/h4&gt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
