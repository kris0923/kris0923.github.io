<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>流光</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-02T14:49:02.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>流光</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>那些所谓的清理僵尸粉，真的能让手机不再卡吗</title>
    <link href="http://yoursite.com/2018/12/02/%E6%B8%85%E7%90%86%E5%83%B5%E5%B0%B8%E7%B2%89/"/>
    <id>http://yoursite.com/2018/12/02/清理僵尸粉/</id>
    <published>2018-12-02T13:23:16.000Z</published>
    <updated>2018-12-02T14:49:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近总收到一些所谓的微信清理僵尸粉的消息，虽然这些消息并不会给我带来多少麻烦（也就是动动手指的事），但正好乘此机会来回顾一下相关的知识</p><h2 id="手机为什么会越用越卡？"><a href="#手机为什么会越用越卡？" class="headerlink" title="手机为什么会越用越卡？"></a>手机为什么会越用越卡？</h2><p>这得从android操作系统说起，android所有的应用程序都运行在Java虚拟机之上，Java虚拟机有自己的内存管理和回收机制。每一个应用程序至少有一个进程，而每个进程都会占用一部分内存资源（这里所说的内存指的是RAM，随机存储器），安卓应用程序总有一些服务进程（比如接收消息推送）在后台运行，所以即使关闭了程序，内存不能完全释放出来，java虚拟机做不到内存的及时回收当开启的进程过多，内存不够时，Java虚拟机就会启用垃圾回收，按照虚拟机内部的算法去杀掉一些后台的进程，实际上垃圾回收器也是一个常驻内存的进程，如果手机的内存不够大，垃圾回收的工作就有可能不能顺利进行，这样手机就卡顿了</p><h2 id="什么是-RAM-和-ROM？"><a href="#什么是-RAM-和-ROM？" class="headerlink" title="什么是 RAM 和 ROM？"></a>什么是 RAM 和 ROM？</h2><p>我们在买手机的时候，关注最多的应该就是手机内存了，现在市场上已经有10GB + 256GB 的手机了，已经超过普通PC机的配置，那么这10GB + 256GB具体指什么呢？为什么会有RAM和ROM之分？<br>按照维基百科的定义<br>RAM：随机存取存储器（英语：Random Access Memory，缩写：RAM），也叫主存，是与CPU直接交换数据的内部存储器。它可以随时读写（，而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储介质）。<br>ROM：只读存储器（Read-Only Memory，ROM）是一种半导体存储器，其特性是一旦存储数据就无法再将之改变或删除，且内容不会因为电源关闭而消失。在电子或计算机系统中，通常用以存储不需经常变更的程序或数据。<br>从RAM 和 ROM的特性我们可以猜到，正常情况下应用程序是存储到ROM中的（断电不丢失数据），而当程序运行时，由于 CPU 的运算效率很高，所以程序需要加载到RAM中才能更好的发挥CPU的性能。<br>在硬件的生产中 RAM 对速度有较高的要求，因此生产成本相对 ROM 要高很多，而且用户也有保存数据的需求，所以手机中就有了RAM和ROM，当然 RAM 要比 ROM 小很多，也就是说10GB + 256GB中，10GB指的是RAM，256GB指的是ROM，RAM越大，可以同时打开的程序就越多，ROM越大，可以存储的照片等文件就越多。</p><h2 id="如果少装软件，手机是否就不卡了？"><a href="#如果少装软件，手机是否就不卡了？" class="headerlink" title="如果少装软件，手机是否就不卡了？"></a>如果少装软件，手机是否就不卡了？</h2><p>理论上看起来是这样，但是用过android手机的都知道事实并非如此。这是因为，一方面，硬件存在老化的问题，硬件的老化会引起手机能耗的提升，导致手机发热，CPU降频，另一方面，即使是同一款软件，也需要不断的更细，新版本的软件基本都是原来的软件基础上打一些修复包或者增加一些新功能，这样软件越来月臃肿，一些软件开发人员在开发过程中使用的测试机也是随着市场变化而更新换代，一些较老的机型在软件开发的时候已经被开发人员放弃了。</p><p>最后来说一下标题的问题，所谓清理僵尸粉，就是删除了微信好友的关系，删除了微信好友关系可以清理一部分聊天记录的缓存，这部分缓存实际占用的 ROM 存储，并不会影响程序的运行流畅度。</p><blockquote><p>在这个由关系组成的社会中，为什么要删除与人的关系呢？</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近总收到一些所谓的微信清理僵尸粉的消息，虽然这些消息并不会给我带来多少麻烦（也就是动动手指的事），但正好乘此机会来回顾一下相关的知识&lt;/p&gt;
&lt;h2 id=&quot;手机为什么会越用越卡？&quot;&gt;&lt;a href=&quot;#手机为什么会越用越卡？&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="游戏人生" scheme="http://yoursite.com/tags/%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>PHP 知识总结（一）</title>
    <link href="http://yoursite.com/2018/09/24/php-summarize/"/>
    <id>http://yoursite.com/2018/09/24/php-summarize/</id>
    <published>2018-09-24T10:41:27.000Z</published>
    <updated>2018-10-04T14:46:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h1><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><ol><li>boolean</li><li>integet</li><li><p>float</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 判断是否是一个数值类型</span><br><span class="line">bool is_nan(float $val)</span><br></pre></td></tr></table></figure></li><li><p>string</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 字符串转数值</span><br><span class="line">//如果 字符串中包含 &apos;.&apos;, &apos;e&apos;或者&apos;E&apos; 转换为float，其余转为 int</span><br></pre></td></tr></table></figure></li><li><p>Array</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 数组的key只能是int 或string</span><br><span class="line">合法的整型字符串会被转成int，例如：&quot;8&quot;，&quot;08&quot;不会，因为08不是合法的十进制数</span><br><span class="line">浮点数也会被转换为整型，意味着其小数部分会被舍去。例如键名 8.7 实际会被储存为 8。</span><br><span class="line">布尔值也会被转换成整型。即键名 true 实际会被储存为 1 而键名 false 会被储存为 0。</span><br><span class="line">Null 会被转换为空字符串，即键名 null 实际会被储存为 &quot;&quot;。</span><br><span class="line">数组和对象不能被用为键名。坚持这么做会导致警告：Illegal offset type</span><br><span class="line">默认键： 当前最大整数索引值加1</span><br><span class="line">// 其他类型转为数组</span><br><span class="line">$a = array($a);</span><br><span class="line">or</span><br><span class="line">$a = (array) $a;</span><br><span class="line">如果一个 object 类型转换为 array，则结果为一个数组，其单元为该对象的属性。键名将为成员变量名，不过有几点例外：整数属性不可访问；私有变量前会加上类名作前缀；保护变量前会加上一个 &apos;*&apos; 做前缀。这些前缀的前后都各有一个 NULL 字符。这会导致一些不可预知的行为：</span><br><span class="line">class A &#123;</span><br><span class="line">    private $A; // This will become &apos;\0A\0A&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">    private $A; // This will become &apos;\0B\0A&apos;</span><br><span class="line">    public $AA; // This will become &apos;AA&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump((array) new B());</span><br><span class="line">//上例会有两个键名为 &apos;AA&apos;，不过其中一个实际上是 &apos;\0A\0A&apos;</span><br></pre></td></tr></table></figure></li><li><p>Object</p></li><li><p>Reource 资源类型</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">资源 resource 是一种特殊变量，保存了到外部资源的一个引用</span><br><span class="line">可以用 is_resource()函数测定一个变量是否是资源，函数 get_resource_type()则返回该资源的类型</span><br></pre></td></tr></table></figure></li><li><p>NULL</p></li><li>Callback/Callable<h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2> <a href="http://php.net/manual/zh/language.oop5.magic.php#" target="_blank" rel="noopener">http://php.net/manual/zh/language.oop5.magic.php#</a> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__construct()，</span><br><span class="line">__destruct()， </span><br><span class="line">__call()， </span><br><span class="line">__callStatic()， </span><br><span class="line">__get()， </span><br><span class="line">__set()， </span><br><span class="line">__isset()， </span><br><span class="line">__unset()， </span><br><span class="line">__sleep()， </span><br><span class="line">__wakeup()， </span><br><span class="line">__toString()， </span><br><span class="line">__invoke()， </span><br><span class="line">__set_state()， </span><br><span class="line">__clone() 和 </span><br><span class="line">__debugInfo()</span><br></pre></td></tr></table></figure></li></ol><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>算数运算符</p><p>$a <strong> $b 表示已$a的$b次方（PHP5.6之后支持）, $a </strong> $b = exp($a*log($a));</p><p>赋值运算符=</p><p>一般情况下赋值运算是将原变量的值拷贝到新变量中，但有个例外，就是碰到对象<em>object</em>时是引用赋值，除非明确使用<em>clone</em>关键字</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;语法基础&quot;&gt;&lt;a href=&quot;#语法基础&quot; class=&quot;headerlink&quot; title=&quot;语法基础&quot;&gt;&lt;/a&gt;语法基础&lt;/h1&gt;&lt;h2 id=&quot;变量类型&quot;&gt;&lt;a href=&quot;#变量类型&quot; class=&quot;headerlink&quot; title=&quot;变量类型&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Mysql事务和锁</title>
    <link href="http://yoursite.com/2018/06/15/%E4%BB%8EHello-World%E5%BC%80%E5%A7%8B/"/>
    <id>http://yoursite.com/2018/06/15/从Hello-World开始/</id>
    <published>2018-06-15T14:50:45.000Z</published>
    <updated>2018-06-17T13:54:41.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是事务&quot;&gt;&lt;a href=&quot;#什么是事务&quot; class=&quot;headerlink&quot; title=&quot;什么是事务&quot;&gt;&lt;/a&gt;什么是事务&lt;/h4&gt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
